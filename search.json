[{"categories":["其他"],"content":"在 markdown 格式下进一步的格式要求。\n基本格式  除学习总结外，不使用一级标题。 代码样式的纯文本块使用 ```text 。 脚注的内容统一放在 参考资料与注释 二级标题下。 数字、粗体、斜体在内的行内特殊字体以及格式需要在两边打上空格（除非一侧为中文标点或在段落开头）。  标点符号  每句话的末尾添加 句号 。 汉语使用全角符号，英语使用半角符号。 注意区分 顿号 与 逗号 的使用。 注意 括号 的位置。句内括号与句外括号的位置不同。 通常使用 分号 来表示列表环境中各复句之间的关系。 使用「 与 」来提高 中文引号 的辨识度。 对于有序列表，每一项的后面添加 分号 ，在列表最后一项的后面添加 句号 ；对于无序列表，在每一项的后面添加 句号 。  文本内容  标题不超过五级。 引用页面时，使用源文章或者标签页的标题，前面附上解释。 所有用作序号的数字使用中文。 避免在标题中使用 MathJax 公式。  LaTeX 公式要求   使用 Roman 体表示常量和函数。使用 Italic 体表示变量。LaTeX 已经预先定义好了一些常见的常量、函数、运算符等，我们可以直接调用，包括但不限于：\n1  \\log, \\ln, \\lg, \\sin, \\cos, \\tan, \\sec, \\csc, \\cot, \\gcd, \\min, \\max, \\exp, \\inf, \\mod, \\bmod, \\pmod   如果遇到没有预先定义好的需要使用 Roman 体的 函数名 ，我们可以使用 $\\operatorname{something}$ 来产生，如我们可以使用 $\\operatorname{lcm}$ 产生正体的最小公倍数（函数）符号。 同理，产生 Roman 体的 常量 应用 $\\mathrm{}$ ；产生 Roman 体粗体符号应用 $\\mathbf{}$ ；产生 Italic 体粗体符号应用 $\\boldsymbol{}$ （如向量）。 对于多字母的变量，应当使用 $\\textit{}$ 。其他非数学内容，包括英文、特殊符号等，一律使用 $\\text{}$ 。中文尽量不放在 LaTeX 公式中。\n  在行内使用分数的时候，使用 $\\dfrac{}{}$ 。\n  组合数使用 \\dbinom{n}{m} 。\n  尽可能避免在行内使用巨运算符（如 $\\sum$ 、 $\\prod$ 、 $\\int$ 等）。\n  叉乘使用 $\\times$ ，点乘使用 $\\cdot$ 。\n  用 $\\cdots$ （居于排版基线与顶线中间）， $\\ldots$ （居于排版基线的位置）， $\\vdots$ （竖着的省略号）\n  复杂度分析时大 $O$ 记号直接使用 $O()$ 。\n  分段函数环境 cases 只能有两列 （即一个 \u0026 分隔符）。\n  不要滥用 LaTeX 公式。一般只用 LaTeX 进行数学书写。\n  空集使用 $\\varnothing$ 。\n  使用 \\begin{aligned} ... \\end{aligned} 表示多行对齐的公式。\n  如果这些多行对齐的公式需要 编号 ，用 align 或 equation 环境。\n  数学公式中的中文文字 必须置于 \\text{} 命令之中 ，而变量、数字、运算符、函数名称则必须置于 \\text{} 命令之外。 不要在 \\text{} 命令中嵌套数学公式。\n  使用 array 环境时注意 实际列数与对齐符号的数量保持一致 。（ l / r / c 分别表示左、右、居中对齐。）\n ","description":"","tags":null,"title":"格式规范","uri":"/posts/style-guide/"},{"categories":["后端"],"content":"继续学习 FastAPI 。\n错误处理 抛出异常 可以采用以下格式来处理异常：\n1 2 3 4 5 6 7 8 9  from fastapi import HTTPException items = {\"foo\": \"The Foo Wrestlers\"} @app.get(\"/items/{item_id}\") async def read_item(item_id: str): if item_id not in items: raise HTTPException(status_code=404, detail=\"Item not found\") return {\"item\": items[item_id]}   有时候为了安全，可能会添加自定义的 headers 来显示错误：\n1 2 3 4 5  raise HTTPException( status_code=404, detail=\"Item not found\", headers={\"X-Error\": \"There goes my error\"} )   我们也可以自定义错误类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  from fastapi import Request from fastapi.responses import JSONResponse class UnicornException(Exception): def __init__(self, name: str): self.name = name # 使用unicorn_exception_handler对自定义的错误类型进行处理 @app.exception_handler(UnicornException) async def unicorn_exception_handler(request: Request, exc: UnicornException): return JSONResponse( status_code=418, content={\"message\": f\"Oops! {exc.name} did something. There goes a rainbow...\"} ) @app.get(\"/unicorns/{name}\") async def read_unicorn(name: str): if name == \"yolo\": raise UnicornException(name=name) return {\"unicorn_name\": name}   重写异常 我们可以采用以下格式来重写异常：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  from fastapi import HTTPException from fastapi.exceptions import RequestValidationError from fastapi.responses import PlainTextResponse # 防止命名冲突 from starlette.exceptions import HTTPException as StarletteHTTPException # 处理请求内容错误 @app.exception_handler(StarletteHTTPException) async def http_exception_handler(request, exc): return PlainTextResponse(str(exc.detail), status_code=exc.status_code) # 处理请求格式错误 @app.exception_handler(RequestValidationError) async def validation_exception_handler(request, exc): return PlainTextResponse(str(exc), status_code=400) @app.get(\"/items/{item_id}\") async def read_item(item_id: int): if item_id == 3: raise HTTPException(status_code=418, detail=\"Nope! I don't like 3.\") return {\"item_id\": item_id}   在上面的例子里，当我们传入 /items/foo 的时候，我们会得到一个 text 类型的错误信息：\n1 2 3  1 validation error path -\u003e item_id value is not a valid integer (type=type_error.integer)   而不是默认的 JSON 格式的错误。内容错误同理。\n但是如果我们只是想把错误捕捉并进行一些处理，返回值还是才用默认的格式，那么我们就可以采用以下格式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  from fastapi.exception_handlers import ( http_exception_handler, request_validation_exception_handler ) # 将错误捕捉并进行打印, 然后按原样返回 @app.exception_handler(StarletteHTTPException) async def custom_http_exception_handler(request, exc): print(f\"OMG! An HTTP error!: {repr(exc)}\") return await http_exception_handler(request, exc) @app.exception_handler(RequestValidationError) async def validation_exception_handler(request, exc): print(f\"OMG! The client sent invalid data!: {exc}\") return await request_validation_exception_handler(request, exc)   接收信息 这里需要 python-multipart 包。\n接收 form 的信息 很方便地直接在定义里面接收数据：\n1 2 3 4 5 6 7 8 9 10  from fastapi import Form # 引入Form # 这里的username和password就从/user/页面的form中接受了对应的信息 # 变量名和form表单里的name对应 @app.post(\"/user/\") async def form_text(request: Request, username: str = Form(...), password: str = Form(...)): return templates.TemplateResponse('index.html', {'request': request, 'username': username, 'password': password})   对应的 form 表单：\n1 2 3 4 5 6 7 8 9 10 11  \u003cform action=\"/user/\" enctype=\"application/x-www-form-urlencoded\" method=\"post\"\u003e \u003clabel\u003eusername\u003c/label\u003e \u003cbr\u003e \u003cinput name=\"username\" type=\"username\" \u003e \u003cbr\u003e \u003clabel\u003epassword\u003c/label\u003e \u003cbr\u003e \u003cinput name=\"password\" type=\"password\" \u003e \u003cbr\u003e\u003cbr\u003e \u003cinput type=\"submit\"\u003e \u003c/form\u003e   接收 file 的信息 File 可以是两种类型，一种是二进制的 bytes 类型，把文件按字节读取；另一种是 UploadFile 类型，里面有记录文件信息的属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  from typing import List # 确保可以接收多个文件 from fastapi import Form, File, UploadFile # 接收多个文件 @app.post(\"/files/\") async def files(request: Request, files_list: List[bytes] = File(...), files_name: List[UploadFile] = File(...)): return templates.TemplateResponse(\"index.html\", {\"request\": request, \"file_sizes\": [len(file) for file in files_list], \"filenames\": [file.filename for file in files_name]}) # 接受单个文件 @app.post(\"/create_file/\") async def create_file(request: Request, file: bytes = File(...), fileb: UploadFile = File(...), notes: str = Form(...)): return templates.TemplateResponse(\"index.html\", {\"request\": request, \"file_size\": len(file), \"notes\": notes, \"fileb_content_type\": fileb.content_type})   前端的表单就可以写成：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u003cform action=\"/files/\" enctype=\"multipart/form-data\" method=\"post\"\u003e \u003cinput name=\"files_list\" type=\"file\" multiple\u003e\u003cbr\u003e\u003cbr\u003e \u003cinput name=\"files_name\" type=\"file\" multiple\u003e\u003cbr\u003e\u003cbr\u003e \u003cinput type=\"submit\" value=\"点击这里显示文件名字与大小\"\u003e \u003c/form\u003e \u003cbr\u003e\u003cbr\u003e\u003cbr\u003e \u003cform action=\"/create_file/\" enctype=\"multipart/form-data\" method=\"post\"\u003e \u003cinput name=\"file\" type=\"file\" multiple\u003e\u003cbr\u003e\u003cbr\u003e \u003cinput name=\"fileb\" type=\"file\" multiple\u003e\u003cbr\u003e\u003cbr\u003e \u003cinput name=\"notes\" type=\"text\" multiple\u003e\u003cbr\u003e\u003cbr\u003e \u003cinput type=\"submit\" value=\"点击这里显示文件属性\"\u003e \u003c/form\u003e   JSON 兼容 jsonable_encoder 可以将上面如请求体的 BaseModel 格式转换为 JSON 格式：\n1 2 3 4 5 6 7 8 9 10 11 12 13  from fastapi.encoders import jsonable_encoder fake_db = {} class Item(BaseModel): title: str timestamp: datetime description: Optional[str] = None @app.put(\"/items/{id}\") def update_item(id: str, item: Item): json_compatible_item_data = jsonable_encoder(item) fake_db[id] = json_compatible_item_data   在上面的例子里，item 被转变成了一个 dict ，dateime 类型也被转换成了 str 。\n依赖 依赖就是在一个函数的形参里面传入一个函数、类、包等，这样函数在调用的时候还要调用依赖项（如果依赖有参数的话还要传依赖的参数），设计的目的是减少重复。\n比如依赖项是一个函数：\n1 2 3 4 5 6 7 8 9 10  from fastapi import Depends async def common_parameters(q: str = None, skip: int = 0, limit: int = 100): limit += 66 return {\"q\": q, \"skip\": skip, \"limit\": limit} @app.get(\"/items/\") async def read_items(commons: dict = Depends(common_parameters)): commons['skip'] += 10 return commons   依赖项是一个类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class CommonQueryParams: def __init__(self, q: str = None, skip: int = 0, limit: int = 100): self.q = q self.skip = skip self.limit = limit @app.get(\"/items/\") async def read_items(commons = Depends(CommonQueryParams)): response = {} if commons.q: response.update({\"q\": commons.q}) items = fake_items_db[commons.skip: commons.skip + commons.limit] response.update({\"items\": items}) return response   依赖项可以嵌套，多个依赖项还可以合在一起（比如打包成一个 list ）传给参数。\n安全 FastAPI 采用了基于 OAuth2 规范的安全性工具。本质上是给登录的用户一个临时有效的令牌。\n获取令牌 下面的例子展示了获取令牌并返回用户数据：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  from fastapi.security import OAuth2PasswordBearer # oauth2_scheme是令牌对象, token: str = Depends(oauth2_scheme)就是加密的令牌 oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\") class User(BaseModel): username: str email: Optional[str] = None full_name: Optional[str] = None disabled: Optional[bool] = None def fake_decode_token(token): return User(username=token + \"fakedecoded\", email=\"john@example.com\", full_name=\"John Doe\") async def get_current_user(token: str = Depends(oauth2_scheme)): user = fake_decode_token(token) return user @app.get(\"/users/me\") async def read_users_me(current_user: User = Depends(get_current_user)): return current_user   令牌是从哪里获得的呢？其实是在 Headers 中。在上述例子中，如果在 Headers 中加入 Authorization: Bearer john （ john 为 token ，前面是固定格式），那么 username = johnfakedecoded 。\n使用密码和 Bearer 的简单 OAuth2 这里我们使用 Bearer 令牌完成一个相对完整的安全性流程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83  from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm # 用户数据(模拟) fake_users_db = { \"johndoe\": { \"username\": \"johndoe\", \"full_name\": \"John Doe\", \"email\": \"johndoe@example.com\", \"hashed_password\": \"fakehashedsecret\", \"disabled\": False, }, \"alice\": { \"username\": \"alice\", \"full_name\": \"Alice Wonderson\", \"email\": \"alice@example.com\", \"hashed_password\": \"fakehashedsecret2\", \"disabled\": True, # 关闭此用户 }, } # 哈希密码(模拟) def fake_hash_password(password: str): return \"fakehashed\" + password # 用户信息模型 class User(BaseModel): username: str email: str = None full_name: str = None disabled: bool = None # 数据库中的用户信息 class UserInDB(User): hashed_password: str # 哈希密码 # 获取用户 def get_user(db, username: str): if username in db: user_dict = db[username] return UserInDB(**user_dict) # 解码令牌(模拟) def fake_decode_token(token): user = get_user(fake_users_db, token) return user # 获取当前用户 # 如果用户不存在则返回HTTP错误 async def get_current_user(token: str = Depends(oauth2_scheme)): user = fake_decode_token(token) if not user: raise HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Invalid authentication credentials\", # 无效的身份验证凭据 # 标准: 任何的401(未认证)错误状态码都应该返回WWW-Authenticate响应头 headers={\"WWW-Authenticate\": \"Bearer\"} ) return user # 获取当前活跃用户 # 如果用户处于非活动状态则返回HTTP错误 async def get_current_active_user(current_user: User = Depends(get_current_user)): if current_user.disabled: raise HTTPException(status_code=400, detail=\"Inactive user\") return current_user # 登录功能 @app.post(\"/token\") async def login(form_data = Depends(OAuth2PasswordRequestForm)): # 使用来自表单字段的username的从数据库获取用户数据 user_dict = fake_users_db.get(form_data.username) if not user_dict: raise HTTPException(status_code=400, detail=\"Incorrect username or password\") # 密码比对 user = UserInDB(**user_dict) hashed_password = fake_hash_password(form_data.password) if not hashed_password == user.hashed_password: raise HTTPException(status_code=400, detail=\"Incorrect username or password\") return {\"access_token\": user.username, \"token_type\": \"bearer\"} @app.get(\"/users/me\") async def read_users_me(current_user: User = Depends(get_current_active_user)): return current_user   OAuth2PasswordRequestForm 声明了如下的请求表单：\n username 。 password 。 一个可选的 scope 字段，是一个由空格分隔的字符串组成的大字符串。 一个可选的 grant_type 。 一个可选的 client_id 。 一个可选的 client_secret 。  这里我们只关注前两个，在 API 文档中点击 Authorize 即可实现登录。\n只有登录成功后才能返回用户信息，否则就会得到一个 401 错误：\n1 2 3  { \"detail\": \"Not authenticated\" }   使用哈希密码和 JWT Bearer 令牌的 OAuth2 JWT 是 「JSON Web Tokens」，需要安装 python-jose[cryptography] 来支持。此外我们安装 passlib[bcrypt] 来处理哈希密码。\n下面是一个 完整的 用户登录并发配令牌的示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125  from datetime import datetime, timedelta from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel # to get a string like this, run: openssl rand -hex 32 # 密钥, 该密钥将用于对 JWT 令牌进行签名 SECRET_KEY = \\ \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" # 选择加密算法 ACCESS_TOKEN_EXPIRE_MINUTES = 30 # 访问令牌过期时间 # 用户数据(模拟) fake_users_db = { \"johndoe\": { \"username\": \"johndoe\", \"full_name\": \"John Doe\", \"email\": \"johndoe@example.com\", \"hashed_password\": \\ \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\", \"disabled\": False, } } class Token(BaseModel): # 令牌 access_token: str token_type: str class TokenData(BaseModel): # 令牌数据 username: str = None class User(BaseModel): # 用户基础模型 username: str email: str = None full_name: str = None disabled: bool = None class UserInDB(User): # 用户输入数据模型 hashed_password: str # 用于密码处理的函数 pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\") # 用于令牌处理的函数 oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/token\") app = FastAPI() # 验证密码 def verify_password(plain_password, hashed_password): return pwd_context.verify(plain_password, hashed_password) # 获取密码哈希 def get_password_hash(password): return pwd_context.hash(password) # 查找数据库, 获取用户 def get_user(db, username: str): if username in db: user_dict = db[username] return UserInDB(**user_dict) # 验证用户 def authenticate_user(fake_db, username: str, password: str): user = get_user(fake_db, username) if not user or not verify_password(password, user.hashed_password): raise HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Incorrect username or password\", headers={\"WWW-Authenticate\": \"Bearer\"}, ) return user # 创建访问令牌 def create_access_token(*, data: dict, expires_delta: timedelta = None): to_encode = data.copy() expire = datetime.utcnow() + expires_delta # expire 令牌到期时间  to_encode.update({\"exp\": expire}) encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM) return encoded_jwt # 获取当前用户 async def get_current_user(token: str = Depends(oauth2_scheme)): credentials_exception = HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Could not validate credentials\", headers={\"WWW-Authenticate\": \"Bearer\"}, ) try: payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM]) username: str = payload.get(\"sub\") if username is None: raise credentials_exception token_data = TokenData(username=username) except PyJWTError: raise credentials_exception user = get_user(fake_users_db, username=token_data.username) if user is None: raise credentials_exception return user # 获取当前未被禁用的用户 async def get_current_active_user(current_user: User = Depends(get_current_user)): if current_user.disabled: raise HTTPException(status_code=400, detail=\"Inactive user\") return current_user # 登录获取令牌 @app.post(\"/token\", response_model=Token) async def login_for_access_token(form_data = Depends(OAuth2PasswordRequestForm)): # 验证用户 user = authenticate_user(fake_users_db, form_data.username, form_data.password) # access_token_expires访问令牌过期 # timedelta表示两个datetime对象之间的差异 access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES) # create_access_token创建访问令牌 access_token = create_access_token(data={\"sub\": user.username}, expires_delta=access_token_expires) # 返回令牌 return {\"access_token\": access_token, \"token_type\": \"bearer\"} @app.get(\"/users/me/\", response_model=User) async def read_users_me(current_user: User = Depends(get_current_active_user)): return current_user   参考资料   这位 B 站 UP 主的视频教程\n  FastAPI 官方文档\n ","description":"","tags":["FastAPI","python","web框架"],"title":"FastAPI 学习笔记（二）","uri":"/posts/fastapi-note-2/"},{"categories":["后端"],"content":"FastAPI 是一个新的基于 Python 语言的 Web 框架，其特点是轻量、安全、快速（号称和 NodeJS, Go 差不多快）。以下是学习笔记（第一部分）。\n（注：代码为了简洁只写出关键部分。）\n基本框架 按照官网所说，安装 fastapi 和 uvicorn[standard] 以及模板引擎 jinja2 、aiofiles（操作静态文件）。（可以直接安装 fastapi[all] 来安装所需的所有包。）整个文件大致的格式就是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  from fastapi import FastAPI, Request from starlette.templating import Jinja2Templates # 和Flask差不多 app = FastAPI() # 使用Jinja2模板, 地址指向同目录下的template templates = Jinja2Templates(directory=\"templates\") # aync用于异步 # 这里的request是固定格式 @app.get(\"/\") async def main(request: Request): return templates.TemplateResponse('index.html', {'request': request, 'hello': 'HI...'}) # 路径参数 @app.get(\"/{item_id}\") async def item_id(request: Request, item_id): return templates.TemplateResponse('index.html', {'request': request, \"item_id\": item_id}) # 查询参数 @app.get(\"/items/\") async def read_item(foo: int = 0, bar: int = 10): return {\"foo\": foo, \"bar\": bar} #多路径也可以 # 如果没有默认值, 那么参数是必填的 @app.get(\"/user/{user_id}/item/{item_id}\") async def read_user_item(user_id: int, item_id: str, q: str = None, short: bool = False): item = {\"item_id\": item_id, \"owner_id\": user_id} if q: item.update({\"q\": q}) if not short: item.update({\"description\": \"This is an amazing item that has a long description\"}) return item # 运行 if __name__ == '__main__': import uvicorn uvicorn.run(app, host=\"127.0.0.1\", port=8000)   值得注意的是，FastAPI 对 类型提示 很敏感，参数是严格按照类型提示来执行的。\n路径参数的顺序问题 如果你有一个获取 /user/me 的函数和一个获取 /user/{user_id} 的函数。应该把前者放在前面 ，因为按照顺序编译的规则，如果 /user/{user_id} 放在前面并且此时 user_id = me ，那么放在后面的 /user/me 就会被覆盖掉。\n交互式 API 文档 FastAPI 的神器。在网址主目录后加上 /docs 即可打开 FastAPI 自带的交互式 API 文档，可以在里面查看各函数的功能以及进行调试。/redoc 是另一种交互式 API 文档。\n静态文件设置路径 设置静态文件夹路径采用以下格式：\n1 2 3  from starlette.staticfiles import StaticFiles app.mount('/static', StaticFiles(directory='static'), name='static')   之后就可以直接使用 url_for 来指定相应的路径了：\n1 2  \u003c!-- 路径指向static文件夹里的bootstrap配置文件 --\u003e \u003clink href=\"{{ url_for('static', path='/css/bootstrap.min.css') }}\" rel=\"stylesheet\"\u003e   参数额外信息和校验 可以通过 Query 将传入的 查询参数 进行 字符串校验 ，不符合要求的参数将报错。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  from fastapi import Query # 限制长度 @app.get(\"/items/\") async def read_items(q: str = Query(..., min_length=3, max_length=50)): #...表示是必填项, 也可以填入默认值, 填None就是默认为空 results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results # 正则表达式 @app.get(\"/items2/\") async def read_items2( q: str = Query(None, min_length=3, max_length=50, regex=\"^nice\") ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results # 默认列表 @app.get(\"/items3/\") async def read_items3(q: List[str] = Query([\"foo\", \"bar\"])): query_items = {\"q\": q} return query_items # 别名参数 # 该别名将用于在 URL 中查找查询参数值 @app.get(\"/items4/\") async def read_items4(q: str = Query(None, alias=\"item-query\")): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results # 弃用参数 # 虽然不会直接报错, 但会在API文档里警告 @app.get(\"/items5/\") async def read_items5( q: str = Query( None, alias=\"item-query\", # 还有在API文档里能更具体表述的title和description title=\"Query string\", description=\"Query string for the items to search \\ in the database that have a good match\", min_length=3, max_length=50, regex=\"^fixedquery$\", deprecated=True, ) ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results   除了查询参数，也可以用 Path 对 路径参数 进行类似的操作。并且所有的这些参数除了字符串校验还可以进行 数值校验 ：\n1 2 3 4 5 6 7 8 9 10 11  from fastapi import Path, Query @app.get(\"/items/{item_id}\") async def read_items( #ge: 大于等于; le: 小于等于; gt: 大于; lt: 小于  item_id: int = Path(..., title=\"The ID of the item to get\", ge=50, le=100), size: float = Query(1, gt=0, lt=10.5) ): results = {\"item_id\": item_id} return results   我们还可以定义 Cookie 参数来接收 Cookie ，其用法和前面的相同：\n1 2 3 4 5  from fastapi import Cookie @app.get(\"/items/\") async def read_items(*, ads_id: str = Cookie(None)): return {\"ads_id\": ads_id}   以及 Header 参数：\n1 2 3 4 5 6 7 8 9  from fastapi import Header @app.get(\"/items/\") async def read_items(user_agent: Optional[str] = Header(None)): return {\"User-Agent\": user_agent} @app.get(\"/items2/\") async def read_items2(x_token: List[str] = Header(None)): return {\"X-Token values\": x_token}   除了拥有和上面的参数相同的功能外，为了兼容 headers 的格式，Header 还会将 - 和大小写进行自动转换（比如用 user_agent 表示 headers 里的 User-Agent ）。\n如果有重复的 headers ，就把类型改成 List 即可将接收的多个信息存到一个 list 中去。\n请求体 基础 可以借助 BaseModel 创建请求体，FastAPI 会将其作为 json 来读取。可以在 API 文档里面很方便地调试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  from pydantic import BaseModel class Item(BaseModel): # 像这样创建一个json格式的类 name: str description: str = None price: float tax: float = None # 用dict()可以将其转换为dict格式 @app.post(\"/items/\") async def create_item(item: Item): print(item.dict()) return item # 还可以同时声明请求体、路径参数和查询参数 @app.put(\"/items/{item_id}\") async def create_item2(item_id: int, item: Item, q: str = None): result = {\"item_id\": item_id, **item.dict()} if q: result.update({\"q\": q}) print(result) return result   请求体的格式就如：\n1 2 3 4 5 6  { \"name\": \"Foo\", \"description\": \"The pretender\", \"price\": 42.0, \"tax\": 3.2 }   请求体中的声明的类型五花八门，可以是 python 内置、python typing 、自定义类、嵌套类型等等，具体可见 Pydantic data types 。\n多个请求体参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  from pydantic import BaseModel class Item(BaseModel): name: str description: Optional[str] = None price: float tax: Optional[float] = None class User(BaseModel): username: str full_name: Optional[str] = None @app.put(\"/items/{item_id}\") async def update_item(item_id: int, item: Item, user: User): results = {\"item_id\": item_id, \"item\": item, \"user\": user} return results   当有多个请求体参数时，请求体会把他们分开来，格式变为：\n1 2 3 4 5 6 7 8 9 10 11 12  { \"item\": { \"name\": \"Foo\", \"description\": \"The pretender\", \"price\": 42.0, \"tax\": 3.2 }, \"user\": { \"username\": \"dave\", \"full_name\": \"Dave Grohl\" } }   单一值嵌入 如果你想把一个值嵌入请求体 而不是作为参数 ，可以采用类似于 Query , Path 的 Body 来实现：\n1 2 3 4 5 6  @app.put(\"/items/{item_id}\") async def update_item( item_id: int, item: Item, user: User, importance: int = Body(...) ): results = {\"item_id\": item_id, \"item\": item, \"user\": user, \"importance\": importance} return results   请求体的格式就会变为：\n1 2 3 4 5 6 7 8 9 10 11 12 13  { \"item\": { \"name\": \"Foo\", \"description\": \"The pretender\", \"price\": 42.0, \"tax\": 3.2 }, \"user\": { \"username\": \"dave\", \"full_name\": \"Dave Grohl\" }, \"importance\": 5 }   请求体嵌入 在仅声明了 一个请求体 参数的情况下，可以将原本的请求体嵌入到一个键中：\n1 2 3 4  @app.put(\"/items/{item_id}\") async def update_item(item_id: int, item: Item = Body(..., embed=True)): results = {\"item_id\": item_id, \"item\": item} return results   这时候请求体格式就是（与 之前 的不同，多了一层 item 的嵌套）：\n1 2 3 4 5 6 7 8  { \"item\": { \"name\": \"Foo\", \"description\": \"The pretender\", \"price\": 42.0, \"tax\": 3.2 } }   字段 与前面的 Body , Query 等相同，我们也可以使用 Fielld 在创建的类内部添加额外信息并进行校验：\n1 2 3 4 5 6 7 8 9 10 11 12 13  from pydantic import Field class Item(BaseModel): name: str # 可以在内部进行设置 description: str = Field(None, title=\"The description of the item\", max_length=6) price: float = Field(..., gt=0, description=\"The price must be greater than zero\") tax: float = None @app.put(\"/items/{item_id}\") async def update_item(*, item_id: int, item: Item = Body(..., embed=True)): results = {\"item_id\": item_id, \"item\": item} return results   响应模型 响应模型实际上就是规定数据的返回类型，FastAPI 能自动帮你实现输入和输出之间的数据转换：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  from pydantic import BaseModel, EmailStr class UserIn(BaseModel): username: str password: str email: EmailStr full_name: str = None class UserOut(BaseModel): username: str email: EmailStr full_name: str = None # 在这里返回的时候, FastAPI能自动帮你把password过滤掉 @app.post(\"/user/\", response_model=UserOut) async def create_user(*, user: UserIn): return user   再者，你还可以手动进行更具体的限定：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  class Item(BaseModel): name: str description: str = None price: float tax: float = 10.5 tags: List[str] = [] items = { \"foo\": {\"name\": \"Foo\", \"price\": 50.2, \"tax\": 10.5}, \"bar\": {\"name\": \"Bar\", \"description\": \"The bartenders\", \"price\": 62, \"tax\": 20.2}, \"baz\": {\"name\": \"Baz\", \"description\": None, \"price\": 50.2, \"tax\": 10.88, \"tags\": []}, } # response_model_exclude_unset=True 默认值将不被考虑, 仅包含实际定义的值 # item_id=foo时就只会返回name, price和tax @app.get(\"/items/{item_id}\", response_model=Item, response_model_exclude_unset=True) async def read_item(item_id: str): return items[item_id] # response_model_exclude={\"tax\"}可以tax # item_id=foo会返回除tax外的所有字段 @app.get(\"/items/{item_id}/public\", response_model=Item, response_model_exclude={\"price\"}) async def read_item_public_data(item_id: str): return items[item_id] # response_model_include只返回要求的字段 @app.get( \"/items/{item_id}/name\", response_model=Item, response_model_include={\"name\", \"description\"} ) async def read_item_name(item_id: str): return items[item_id]   除此之外，还有 response_model_exclude_defaults=True , response_model_exclude_none=True ，详见 Pydantic 文档 。\n相应状态码 FastAPI 可以定义返回的 HTTP 状态码（详见 MDN文档 ），更方便的是使用来自 fastapi.status 的便捷变量，这样就能借助自动补全快速输入了：\n1 2 3 4 5 6 7 8 9 10 11 12  from fastapi import FastAPI, status # status_code定义返回状态码 @app.post(\"/items/\", status_code=201) async def create_item(name: str): return {\"name\": name} # 使用status里面的宏 @app.post(\"/items3/\", status_code=status.HTTP_404_NOT_FOUND) async def create_item3(name: str): print('HTTP_404:', status.HTTP_404_NOT_FOUND) return {\"name\": name}   更多路径操作 除了响应模型和状态码，还有一些其他的路径参数，它们可以使 API 文档更加完善。\n标签 添加标签后，在 API 文档中就会按照标签的异同对函数进行分类：\n1 2 3 4 5 6 7 8 9 10 11  @app.post(\"/items/\", response_model=Item, tags=[\"items\"]) async def create_item(item: Item): return item @app.get(\"/items/\", tags=[\"items\"]) async def read_items(): return [{\"name\": \"Foo\", \"price\": 42}] @app.get(\"/users/\", tags=[\"users\"]) async def read_users(): return [{\"username\": \"johndoe\"}]   上面的例子中，前两个函数会被分到 items 里，最后一个被分到 users 里。\n弃用 和前面弃用参数一样，你也可以用 deprecated 标记表示临时弃用，标记的函数会在 API 文档里灰色显示。\n1 2 3  @app.get(\"/elements/\", tags=[\"items\"], deprecated=True) async def read_elements(): return [{\"item_id\": \"Foo\"}]   pydoc API 文档会读取 pydoc 作为文档里函数的介绍，支持 Markdown 格式。\n参考资料   这位 B 站 UP 主的视频教程\n  FastAPI 官方文档\n ","description":"","tags":["FastAPI","python","web框架"],"title":"FastAPI 学习笔记（一）","uri":"/posts/fastapi-note-1/"},{"categories":["编程语言"],"content":"简记一些常用的函数和 STL 。\nC library ctype 1 2 3 4 5 6 7  int isalnum(int c); //判断c是否为字母或数字 int isdigit(int c); //判断c是否为数字 int isalpha(int c); //判断c是否为字母 int islower(int c); //判断c是否为小写字母 int isupper(int c); //判断c是否为大写字母 int tolower(int c); //大写转小写 int toupper(int c); //小写转大写   math 1 2 3 4 5  double atan2(double y,double x); //返回(x,y)对应的弧度值 double cbrt(double x); //立方根 double hypot(double x,double y); //勾股定理斜边 double fmod(double x,double y); //返回x/y的小数余数 double round(double x); //返回x四舍五入的值，llround()返回long long   stdlib 1 2  int atoi(const char*str); //字符串转为int，atof(),atoll()同理 long long llabs(long long x); //返回绝对值   string 1 2 3 4 5 6 7 8 9 10 11  char*strcpy(char*s1,const char*s2); //将s2复制进s1 char*strncpy(char*s1,const char*s2,size_t n); //将s2前n个字符复制进s1，注意手动'\\0' char*strcat(char*s1,const char*s2); //将s2接在s1后面，strncat()类比strncpy() char*strcmp(const char*s1,const char*s2); //s1=s2返回0，s1\u003es2返回大于0的值，s1\u003cs2返回小于0的值，strncmp()类比strncpy() char*strchr(const char*s,int c); //返回c在s中出现的第一个位置 char*strrchr(const char*s,int c); //返回字符c在s中出现的倒数第一个位置 char*strpbrk(const char*s1,const char*s2); //返回s1中含有s2字符的第一个位置 char*strstr(const char*s1,const char*s2); //返回s1中s2第一次出现的位置  char*strtok(char*str,const char*de); //用de中含有的所有字符作为标识将str分隔   strtok() 在之后的使用中使用 NULL 来作为指针，例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  #include\u003cstdio.h\u003e#include\u003cstring.h\u003eint main(){ char str[] =\"- This, a sample string.\"; char*pch; pch=strtok(str,\" ,.-\"); while(pch!=NULL){ printf(\"%s\\n\",pch); pch=strtok(NULL,\" ,.-\"); } return 0; } /* Output: This a sample string */   C++ 拓展库 rope 使用 ext/rope 库，需在命名空间 __gnu_cxx 下使用。\n1 2 3 4 5 6 7 8 9 10 11 12  rope\u003cT\u003e rp; crope rp; //特化的rope, 相当于rope\u003cchar\u003e, 可以理解为一个强化的string // 常用函数 rp.push_back(x); // 在末尾插入 x rp.append(...) //插入, 可以插入一串数, 和 stl 挺像 rp.insert(pos, x); // 在 pos 处插入 x rp.erase(pos, x); // 在 pos 处删除 x 个元素 rp.size(); // 返回 rp 的大小 rp.replace(pos, x); // 将 pos 处的元素替换成 x rp.substr(pos, x); // 从 pos 处开始提取 x 个元素 rp.copy(pos, x, s); // 从 pos 处开始复制 x 个元素到 s 中 rp[x]; // 访问第 x 个元素   可以用它实现可持久操作：\n1 2  rope\u003cint\u003e *his[N]; his[i] = new rope\u003cint\u003e (*his[i - 1]);   pb_ds 一般需要 ext/pb_ds/assoc container.hpp 以及命名空间 __gnu_pbds 。\nhash 需要 ext/pb_ds/hash_policy.hpp 。\n有 cc_hash_table\u003ckey, value\u003e  和 gp_hash_table\u003ckey, value\u003e ，后者效果好一点。\n支持 find 和 operator[] 。\n如果不自己写 hash 函数，没有 unordered_map 快。\ntree 需要 ext/pb_ds/tree_policy.hpp 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  tree\u003cT, null_type, less\u003cT\u003e, rb_tree_tag, tree_order_statistics_node_update\u003e tr; /* T 存储的类型 null_type 无映射(有映射就是个map, 存的是个pair) less\u003cT\u003e 从小到大排序 rb_tree_tag 红黑树, 只用它 tree_order_statistics_node_update 更新方式 */ // 基础操作 begin(), end(), size(), empty(), clear() insert(pair\u003ckey, T\u003e), erase(iter), erase(key), operator[] find(key), lower_bound(key), upper_bound(key) // 高级操作 order_of_key(key); // 返回比key小的元素个数 find_by_order(size_type order); //找order + 1小值的迭代器, 太大返回end() join(tree \u0026other); //将other并入，前提是两棵树类型一样且值域不相交 tr.split(key, tree \u0026other); //清空other, 然后把大于key   tire 1 2 3 4 5 6 7 8 9 10  typedef trie\u003cstring,null_type,trie_string_access_traits\u003c\u003e,pat_trie_tag,trie_prefix_search_node_update\u003e tr; //第一个参数必须为字符串类型，tag也有别的tag，但pat最快，与tree相同，node_update支持自定义 tr.insert(s); //插入s tr.erase(s); //删除s tr.join(b); //将b并入tr // 找tire中包含x的串 pair\u003ctr::iterator,tr::iterator\u003e range=base.prefix_range(x); for(tr::iterator it=range.first;it!=range.second;it++) cout\u003c\u003c*it\u003c\u003c' '\u003c\u003cendl; //pair中第一个是起始迭代器，第二个是终止迭代器，遍历过去就可以找到所有字符串了。   priority_queue 1 2 3 4 5 6 7 8 9 10 11 12 13  priority_queue\u003cint,greater\u003cint\u003e,TAG\u003e Q;//小根堆，大根堆写less\u003cint\u003e /* TAG只用默认的pairing_help_tag 有时候可以试试binary_heap_tag */ // 同stl的 push(x), pop(), top(), empty(), size() // 可迭代 priority_queue\u003c...\u003e::point_iterator it begin(), end() // 高级 modify(iterator, x), erase(iterator) join(other) // 合并后other清空   ","description":"","tags":["C/C++","ICPC"],"title":"C/C++库函数及容器","uri":"/posts/c-c++stl/"}]
